/*
* 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
* */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumbers = function(nums) {
    /*
    * ^运算符  按位异或 若参加运算的两个二进制位值相同则为0，否则为1  也就是说两个相同的运算符的按位异或为0  所以整个数组按位异或 === 其中两个不同的数按位异或
    * 假如结果为 a ^ b = tem  所以 tem的二进制中为1的位，对应 a 和 b的位那就是不一样的  比如 24(0b11000) 高位的两个1 ，对应到a,b的两个位置，是不一样的，一个是0，一个是1，按位异或的结果才能是1
    * &运算符  按位与  如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
    * 我们从1开始找，由低位到高位找tem中哪一位是1，比如 24(0b11000) & 1(0b00001) 肯定为 0
    * <<运算符 左移 用来将一个数的各二进制位全部左移N位，右补0  1(0b00001) <<1 == 2(0b00010)  2<<1 == 4(0b00100)
    * 这样循环，我们就能找到tem中的最低为1的那一位
    *
    * 然后使用dev和数组中的每一个数按位与运算便可以将数组分为两组
    * 因为 相同的数和dev按位与，必然是相同的结果，所以不会将两个相同的数分到不同的数组里面
    * 又因为 dev中1的那一位在a、b中肯定不是一样的，所以，a、b会分为两个数组
    * 最后分别计算两个数组的按位异或就可以了
    *
    * 秒啊
    * */
    let tem = 0
    for (let i = 0; i < nums.length; i ++) {
        tem ^= nums[i]
    }
    let dev = 1
    while ((dev & tem) === 0) {
        dev = dev << 1
    }
    let left = 0,right = 0
    for (let i = 0;i < nums.length;i ++) {
        if ((dev & nums[i]) === 0) {
            left ^= nums[i]
        }else{
            right ^= nums[i]
        }
    }
    return [left,right]
};
console.log(singleNumbers([4, 1, 4, 6]));